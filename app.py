# podcast_gemini_project/app.py
import os
import uuid
import logging
from flask import Flask, request, jsonify, render_template, send_from_directory
from werkzeug.utils import secure_filename
import google.generativeai as genai
from gtts import gTTS
import pdfplumber

import config

# Initialize logging
config.setup_logging()
logger = logging.getLogger(__name__)

# Configure Gemini API
if config.GEMINI_API_KEY:
    genai.configure(api_key=config.GEMINI_API_KEY)
else:
    logger.error("GEMINI_API_KEY not found. Please set it in your .env file.")
    # Potentially exit or disable AI features if key is critical

# Flask App Initialization
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = config.UPLOAD_FOLDER
app.config['PODCAST_AUDIO_FOLDER'] = config.PODCAST_AUDIO_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit

# Ensure upload and podcast audio directories exist
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['PODCAST_AUDIO_FOLDER'], exist_ok=True)

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in config.ALLOWED_EXTENSIONS

def extract_text_from_file(filepath):
    """Extracts text from PDF or TXT files."""
    _, extension = os.path.splitext(filepath)
    text = ""
    try:
        if extension.lower() == '.pdf':
            with pdfplumber.open(filepath) as pdf:
                for page in pdf.pages:
                    page_text = page.extract_text()
                    if page_text:
                        text += page_text + "\n"
        elif extension.lower() == '.txt':
            with open(filepath, 'r', encoding='utf-8') as f:
                text = f.read()
        logger.info(f"Successfully extracted text from {os.path.basename(filepath)}.")
        return text.strip()
    except Exception as e:
        logger.error(f"Error extracting text from {filepath}: {e}")
        return None

async def generate_podcast_script_gemini(document_text: str, user_query: str) -> str | None:
    """Generates podcast script using Gemini API."""
    if not config.GEMINI_API_KEY:
        logger.error("Gemini API key not configured. Cannot generate script.")
        return None
    try:
        model = genai.GenerativeModel(config.GEMINI_MODEL_NAME)
        prompt = config.PODCAST_SCRIPT_PROMPT_TEMPLATE.format(
            user_query=user_query,
            document_text=document_text[:30000] # Truncate for safety, Gemini Pro 1.5 has large context
        )
        
        logger.info(f"Sending request to Gemini for podcast script generation. Query: {user_query[:50]}...")
        # Using generate_content_async for potential future async handling in Flask
        response = await model.generate_content_async(prompt)
        
        if response.parts:
            script = "".join(part.text for part in response.parts if hasattr(part, 'text'))
            logger.info(f"Podcast script generated by Gemini. Length: {len(script)}")
            return script.strip()
        elif response.prompt_feedback and response.prompt_feedback.block_reason:
            logger.error(f"Gemini script generation blocked. Reason: {response.prompt_feedback.block_reason_message}")
            return f"Error: Script generation was blocked by the API. {response.prompt_feedback.block_reason_message}"
        else:
            logger.warning("Gemini response did not contain text parts for the script.")
            return None

    except Exception as e:
        logger.error(f"Error calling Gemini API: {e}", exc_info=True)
        return f"Error: An issue occurred while communicating with the AI model: {str(e)}"


def text_to_speech_gtts(text: str, output_filename: str, lang: str = 'en') -> str | None:
    """Converts text to speech using gTTS and saves it."""
    try:
        output_path = os.path.join(app.config['PODCAST_AUDIO_FOLDER'], output_filename)
        logger.info(f"Generating speech (gTTS) for text (length: {len(text)}) to {output_path}...")
        tts = gTTS(text=text, lang=lang, slow=False)
        tts.save(output_path)
        logger.info(f"Speech generated successfully (gTTS): {output_path}")
        return output_filename # Return just the filename for serving
    except Exception as e:
        logger.error(f"Error during gTTS text-to-speech conversion: {e}", exc_info=True)
        return None

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate_podcast', methods=['POST'])
async def generate_podcast_route():
    if 'document' not in request.files:
        return jsonify({"error": "No document file part"}), 400
    
    file = request.files['document']
    user_query = request.form.get('query', "Provide a general overview of the document.")

    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file and allowed_file(file.filename):
        filename_secure = secure_filename(file.filename)
        # Use a UUID to ensure unique filenames for temporary storage
        unique_id = str(uuid.uuid4())
        temp_filename = f"{unique_id}_{filename_secure}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], temp_filename)
        
        try:
            file.save(filepath)
            logger.info(f"File '{filename_secure}' saved temporarily as '{temp_filename}'.")

            document_text = extract_text_from_file(filepath)
            if not document_text:
                return jsonify({"error": "Could not extract text from the document."}), 500

            podcast_script = await generate_podcast_script_gemini(document_text, user_query)
            if not podcast_script:
                return jsonify({"error": "Failed to generate podcast script from AI."}), 500
            if podcast_script.startswith("Error:"): # Check if Gemini returned an error message
                 return jsonify({"error": podcast_script, "script": podcast_script}), 500


            audio_filename_base = f"podcast_{unique_id}"
            audio_filename_mp3 = f"{audio_filename_base}.mp3"
            
            generated_audio_filename = text_to_speech_gtts(podcast_script, audio_filename_mp3)

            if not generated_audio_filename:
                # Still return the script even if TTS fails
                return jsonify({
                    "error": "Failed to generate audio, but script is available.",
                    "script": podcast_script,
                    "audio_url": None
                }), 500

            audio_url = f"/serve_audio/{generated_audio_filename}"
            
            return jsonify({
                "message": "Podcast generated successfully!",
                "script": podcast_script,
                "audio_url": audio_url,
                "original_document_name": filename_secure
            })

        except Exception as e:
            logger.error(f"Error in /generate_podcast: {e}", exc_info=True)
            return jsonify({"error": f"An unexpected server error occurred: {str(e)}"}), 500
        finally:
            # Clean up the uploaded temporary file
            if os.path.exists(filepath):
                try:
                    os.remove(filepath)
                    logger.info(f"Cleaned up temporary uploaded file: {filepath}")
                except OSError as e_remove:
                    logger.error(f"Error removing temporary file {filepath}: {e_remove}")
            # Note: Audio files are not cleaned up automatically in this simple version.
            # A production system would need a cleanup strategy for generated audio.
    else:
        return jsonify({"error": "File type not allowed."}), 400

@app.route('/serve_audio/<filename>')
def serve_audio(filename):
    # Basic security: ensure filename is just a filename and not a path
    if ".." in filename or filename.startswith("/"):
        return "Invalid filename", 400
    try:
        return send_from_directory(app.config['PODCAST_AUDIO_FOLDER'], filename, as_attachment=False)
    except FileNotFoundError:
        logger.warning(f"Audio file not found for serving: {filename}")
        return "Audio file not found", 404
    except Exception as e:
        logger.error(f"Error serving audio file {filename}: {e}", exc_info=True)
        return "Error serving audio", 500


if __name__ == '__main__':
    if not config.GEMINI_API_KEY:
        print("CRITICAL: GEMINI_API_KEY is not set. The application will not function correctly.")
        print("Please set it in your .env file and restart.")
    app.run(debug=True, host='0.0.0.0', port=5001) # Use a different port if 5000 is common